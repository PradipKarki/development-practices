This document identifies CWDS common (shared) code standards in an effort to help improve software quality by having a common standard across development teams. The project comprises of several vendors with different coding standards and philosophies which can cause confusion among teams that interact. A common standard helps set expectation among all team members.

The CWDS CARES project was initiated with a commitment to agile principles and practices with the expectation that team members will be committed to such practices. Shared libraries promotes code reuse, standardizes coding implementations, increases development velocity, and benefits from using stable and mature existing code. Minimizing code duplication is a key agile practice, which developers are expected to follow such practices.

# Standards
CWDS expects developers to minimize code duplication through the use of common code that is aggregated into common shared libraries. Developers are expected to use and contribute to existing shared libraries, and to create them when they are needed but do not exist. Developers must contribute common code back to shared libraries.

# Shared Code
Shared code is software that can be reused in various applications. Reusable code components may only be small functions that are part of a utility class such as date formatters or part of a larger framework that handles configuring of an application such as DropWizard, or a common library such as the UI Component Library. Shared components exist in all development domains including but not limited to Java, Javascript, Ruby, UI components, CSS, SQL, etc. Some examples of shareable code: Helpers (date & time functions, transformers, and  formatters), common layered components (DTOs, DAO), integration components (data converters, messaging components ), shareable framework components (Dropwizard application configurations, db connections, custom frameworks), UI components (CSS, JavaScript, react), ect.

By reusing shared code we improve the development process and code quality by improving development velocity, minimizing bugs, unifying common implementation patterns, and reducing the size of the application code base. Not using libraries will slow down teams since they will have to create the code themselves to solve potentially complex problems that have already been coded. Creating new code may introduce bugs and a different implementation concept others may not be familiar with. Multiple projects solving the same problem differently increases complexity between the applications and can cause maintenance issues.

## Duplicate Code Considerations
Developing shared code requires some careful considerations to prevent introducing anti-patterns. Sharing code is a desired practice but not all code is a good candidate for sharing. Some code may appear to be duplication (same methods, properties, etc), but the context the class is used in may differ. The code can change for different reasons if the context is different and it MAY be beneficial to have "duplicate" code in these cases. For example, a domain and entity class may have many of the same properties and methods, however, one class may have special domain knowledge that the entity wouldn't not have. An entity class maps to the DB and will have to change if the DB changes. However, we may want the business object isolated from a database/entity change. It may be appropriate to have both extend a common class to reduce duplication, but then both are bound to the same properties and types which may not be desirable. Using good judgment and design principles will usually mitigate duplication issues.

## Code Changes
Shared code needs to be developed in a manner that allows for code reuse. Code should be abstract enough to be used across multiple projects and for multiple purposes. Although decomposing classes is always important, shared code may require code to be broken into further classes to allow for more flexibility. Dependencies should be configurable. Some modification will not be evident until the code is used in a different context or use case. In these cases the code will need to be alter the code to provide the necessary changes, which may include refactoring and introducing new abstractions.

Code changes should be performed with care since the code is shared. Shared code should derive from a contract which clients expect to be stable (i.e. not changing). Changes can inadvertently cause unintended side effects which may break client code. Care must be taken to preserve the exposed contract and should be included in the tests. Developers need to account for how their changes will impact other users.

Contracts should not change once code is available to the clients. Only algorithm improvements, refactoring, or side effects NOT visible to the client such as logging  should be performed. In the cases where there is a problem with the contract, then great care should be taken to handle the situation. Preferably, the code should be deprecated and replaced. In the event a breaking change is made, then the clients must be notified.

# Testing
All code should contain tests. Shared code should include tests that verify functionality and enforce the contract. Updates should not break any existing tests that focus on contracts since that would break clients that depends on that contract. The implementing code may choose to add tests or to mock out the shared code to verify the contract doesn't change during an update.

Shared code test should not only test functionality, but should also demonstrate code usage. Tests are great for showing examples of using the code.
